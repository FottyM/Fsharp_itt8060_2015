module BrokenRomanNumbers


open System.Collections.Generic
open NUnit.Framework
open FsUnit


let rec check_separation (str:string) =
    let numerals = [('I', 1); ('V', 5); ('X', 10); ('L', 50); ('C', 100); ('D', 500); ('M', 1000)]
    let mutable idx = new Dictionary<char,int>()
    ['V', 1; 'I', 0;  'X', 2; 'L', 3; 'C', 4; 'D', 5; 'M', 6] |> Seq.iter idx.Add
    let mutable success = false
    for i in [0 .. str.Length-2] do
        let ch = str.Chars(i)
        if i < str.Length-2 then
            if (str.[i+1] = ch && (larger_number_after (i+1) ch str)) then
                success <- true
            for j in [idx.[ch]+1 .. numerals.Length-1] do
                if i < str.Length-1 && ch <> 'I' then
                    if str.[i+1] = 'M' && str.[i] = 'C' or 
                       str.[i+1] = 'X' && str.[i] = 'C' or 
                       str.[i+1] = 'L' && str.[i] = 'X' then
                       ()
                    elif str.[i+1] = fst numerals.[j] then
                       success <- true               
    success

and larger_number_after (i:int)  (ch:char)  (str:string) =
    let mutable numerals = new Dictionary<char,int>()
    ['M', 1000; 'D', 500; 'C', 100; 'L', 50; 'X', 10; 'V', 5; 'I', 1] |> Seq.iter numerals.Add
    let mutable success = false
    for i in [i .. str.Length-2] do
        if numerals.[str.[i+1]] > numerals.[ch] then
            success <- true
    success



(*
    A smaller number in front of a larger number means subtraction, all else means addition.
    For example, IV means 4, VI means 6.

    You wouldn't put more than one smaller number in front of a larger number to subtract.
    For example, IIV would not mean 3.

    You must separate ones, tens, hundreds, and thousands as separate items.
    That means that 99 is XCIX, 90 + 9, but never should be written as IC. 
    Similarly, 999 cannot be IM and 1999 cannot be MIM.

    Author: Steve Fortuneseeker
    
*)
let convert(input:string)=
        if input.GetType().Equals(typeof<string>) then
            if (input.Replace("M", "").Replace("D", "").Replace("C", "").Replace("L", "").Replace("X", "").Replace("V", "").Replace("I", "")).Length > 0 then
               failwith "invalid input"
        let sum = 0
        if (input.IndexOf("IIIII") > -1) or input.IndexOf("VV") > -1 or input.IndexOf("XXXXX") > -1 or
          input.IndexOf("DD") > -1 or input.IndexOf("CCCCC") > -1 then
            failwith "invalid input"
        if input.IndexOf("IIV") > -1 or input.IndexOf("IIX") > -1 or input.IndexOf("IC") > -1 or
          input.IndexOf("IL") > -1 or input.IndexOf("ID") < -1 or input.IndexOf("IM") > -1 or
           (check_separation input ) then
             failwith "invalid input"
        let mutable sum=0
        for i in [0 .. input.Length-1] do
            let ch = input.Chars(i)
            if ch = 'M' then
                if larger_number_after i  ch input then
                    sum <- sum - 1000
                else
                    sum <- sum + 1000
            elif ch = 'C' then
                if larger_number_after i  ch input then
                    sum <- 100 - sum
                else 
                    sum <- sum + 100
            elif ch = 'D'then
                if larger_number_after i ch input then
                    sum <- sum - 500
                else
                    sum <- sum + 500
            elif ch = 'L' then
                if larger_number_after i ch input then
                    sum <- sum - 50
                else 
                    sum <- sum + 50
            elif ch = 'V' then
                if larger_number_after i ch input then
                    sum <- sum - 5
                else
                    sum <- sum + 5
            elif ch = 'X' then
                if larger_number_after i ch input then
                    sum <- sum - 10
                else
                    sum <- sum + 10
            elif ch = 'I' then
                if larger_number_after i ch input then
                    sum <- sum - 1
                else 
                    sum <- sum + 1
        sum
 (* Test cases:
1. The output will be generated by tallying 1, 5, 10, 50, 100, 500, and 1000, 
using the symbols "I", "V", "X", "L", "C", "D" and "M" respectively.
2.The symbols must be written in descending order: "M" before "D" before "C" before "L", etc.
Using the tallying logic, it's clear that we can only have up to four repetitions of "I", "X", "C" and "M". 
And only one "V", "L" or "D". 
Any more than that and the multiple tally marks are abbreviated to the next "higher" tally mark.
3.Finally, we have the six (optional) substitution rules: "IIII"=>"IV", "VIIII"=>"IX", "XXXX"=>"XL",
 "LXXXX"=>"XC", "CCCC"=>"CD", "DCCCC"=>"CM". These are exceptions to the descending order rule.*)     
     
//In the Roman numeral system, the basic "digits" are the letters I, V, X, L, C, D, 
//and M which represent the same numbers regardless of their position.

[<Test>] 
let ``For certain inputs pairs, expect matching outputs, the happy path``() = 
    let testpairs = [ 
      ("I",1)
      ("V",5)
      ("X",10)
      ("L",50)
      ("C",100)
      ("D",500)
      ("M",1000)
      //I, V, X, L, C, D, and M
      ]
    for (roman,expectedArabic) in testpairs do
       let gottenArabic = convert roman
       Assert.AreEqual(expectedArabic, gottenArabic)  

[<Test>]
    let `` For a given number XCIX it should convert to 99`` ()=
        convert "IXC" |> should equal 99

[<Test>] 
let `` Nines``() = 
    let testpairs = [ 
      ("IX",9)
      ("LIX",59)
      ("XCI",91)
      ("CDXCI",490)
      ("CMI",901)
      //I, V, X, L, C, D, and M
      ]
    for (roman,expectedArabic) in testpairs do
       let gottenArabic = convert roman
       Assert.AreEqual(expectedArabic, gottenArabic) 


//Do not repeat I, X, and C more than three times in a row. 
//(Number 4 on a Roman numeral clock is usually written as IIII. )
[<Test; ExpectedException(typeof<System.Exception>)>]
    let ``There cannot be more than tree I in a row`` () = "IIII" |> convert |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let ``There cannot be more than tree X in a row`` () =  "XXXX" |> convert |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let ``There cannot be more than tree C in a row`` () =  "CCCC" |> convert |> ignore 


//Symbols are placed in order of value, starting with the largest values.
[<Test; ExpectedException(typeof<System.Exception>)>]
    let``When given VXL it should give an Exception`` ()= convert "VXL" |> ignore

[<Test; ExpectedException(typeof<System.Exception>)>]
    let ``When given DCLXI it should give me 661`` ()= convert "IXLCD" |> ignore

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` When given LCDM it should throw an error`` () = convert "LCDM" |> ignore


//Symbols V, L, and D cannot appear more than once consecutively.

[<Test; ExpectedException(typeof<System.Exception>)>]
    let ``When given a VV it should throw an error `` ()= convert "VV" |> ignore

[<Test; ExpectedException(typeof<System.Exception>)>]
    let ``When given a LL it should throw an error `` ()= convert "LL" |> ignore // => doesn't work 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let ``When given a DD it should throw an error `` ()= convert "DD" |> ignore

[<Test; ExpectedException(typeof<System.Exception>)>]
    let ``When given a LC it should throw an error `` ()= convert "LC" |> ignore// this doesn't work

// Do not subtract a number from one that is more than 10 times greater: 
//I may only precede V and X, X may only precede L and C, and C may only precede D and M.

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given IL it should throw an error `` () = convert "IL" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given IC it should throw an error `` () = convert "IC" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given ID it should throw an error `` () = convert "ID" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given IM it should throw an error `` () = convert "IM" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given VL it should throw an error `` () = convert "VL" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given VC it should throw an error `` () = convert "VC" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given VD it should throw an error `` () = convert "VD" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given VM it should throw an error `` () = convert "VM" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given XD it should throw an error `` () = convert "XD" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given XM it should throw an error `` () = convert "XM" |> ignore 

[<Test; ExpectedException(typeof<System.Exception>)>]
    let `` when given LM it should throw an error `` () = convert "LM" |> ignore 
